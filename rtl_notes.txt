第一章基础语法知识：
1、verilog语法学习，使用蔡觉平老师的书籍与网络视频课
    ①语言要素的学习：空白符、注释符、标识符、关键字、数值的理解
    ②数据类型：物理数据类型，连线型和寄存器，存储器类型，抽象数据类型
    ③wire 和 reg 数据类型的使用场景选择分析：
       wire(导线) ：赋值方式(assign+模块端口之间)     reg(触发器、锁存器)：always 、initial  语句块内，
       使用技巧：看左边定类型，assign用wire，always 用reg  
2、寄存器类型与存储器类型的区别：                 
    ①reg 是一种数据对象类型，在 always 或 initial 块中赋值）的变量  硬件对应：触发器、锁存器    用于存储单个数据
    ②memory 由多个 reg 变量组成的一维或多维数组，对应数据结构，硬件对应：RAM ROM SRAM  
    ③声明一个存储器（1024 x 8位的RAM）：reg [7:0] ram [0:1023];
3、理解抽象数据类型：
    ①常见类型：整型(integer)，实数型(real),字符串(string), 时间型(time)   都没有对应的硬件，且不可以综合，用于仿真、

4、阻塞语句（=）、非阻塞的本质区别（<=）
   ① =，顺序执行，立即计算=右边，然后立即赋值给=左边，每条指令结束再执行下一条指令。
    硬件层面：对应组合逻辑，中间没有触发器做隔离，输入变化会立即导致逻辑运算，
    使用场景：组合逻辑设计
   ②<=，并行执行，所有=右边同时计算，然后同时统一赋值更新=左边，在整个语句块中同时进行。对应时序逻辑
    硬件层面：非阻塞语句对应中间存在触发器采样处理，但是新采样的值都需要等待下一个时钟周期。所以在一个语句快内，
                        所有的=左边的计算都属于当前时钟周期的同步采用，而赋值属于下一周的采样更新处理。
    使用场景：组合逻辑设计：直接使用阻塞即可，所有的赋值结果都是立即执行
            时序逻辑设计：①语句块使用阻塞的结构是导致时序错误，所有赋值执行都属于本周的数据
                        ②语句块使用非阻塞结束会使得寄存器的输入端基于上一周期的寄存器保存值进行赋值执行，符合时序分析
            数据类型属于wire变量的逻辑运算都是基于本周期的数据立即赋值执行，属于物理硬件线路的特点
            数据类型属于reg变量的运算：
                        ①reg变量参与运算(<=右边)：reg变量的值基于寄存器存储上一周期的值计算，时钟来临时进行赋值给到<=左边

     ①算术运算符：+  -  *  /  %    运算有无符号取决于操作数的数据类型。混合运算时无符号默认提升有符号，易出错。溢出自动截断高位
     ②关系运算符：>  <  >=  <=   返回单比特值：1 / 0
     ③相等运算符：==  !=  ===  !==    ==和！=（不比较x/z 若存在x/z 则结果为x） ===和！== (比较x/z 主要用于testbench仿真)
     ④逻辑运算符：!   &&   ||     操作位可以多位的，返回值为单比特结果；存在短路求值：a && b，如果 a 为0，则不会计算 b (仿真器的行为)
     ⑤按位运算符：~   &   |   ^    ~^     操作数位宽不同，较短的操作数会在高位补0； yu逻辑运算不同，返回值按位产生同等位数据结果
     ⑥归约运算符：串行处理单一变量的多位宽，从左向右相邻位宽逻辑运算最后纵向压缩成单比特位：0 / 1   
     ⑦移位运算符：<<   >>   <<<    >>>    逻辑移位视为无符号数，空位补0；算术移位视为有符号运算，
         算术移位保持高位符号不变，高位空缺补符号位，低位补0；特别是算术右移：右移近似于除以2的幂
     ⑧条件运算符：?     条件1 ？表达真：表达假    相当于综合一个2路选择器    ；可以嵌套使用
     ⑨连接与复制：{ }     {{  }}     假设a=1'b1,b=2'b10
         连接：{ }    c = {a,b} = 3'b110       连接：属于位宽之间的直接拼接，直接增大位宽。
         复制：{{}}   d = {2{a}} = 2b'10      
         混合：连接与复制   e = {c,{2{a}}}    嵌套使用从最里面往外看，先复制，后连接    e= 5'b11010

6、模块和端口的关系，以及模块实例化：
     ①子模块之间的连接属于物理层面的连线，全局声明wire变量用于模块A的输出连接模块B的输入
     ②模块本身的端口数据类型严格按照数据类型分类，常见常用wire 与reg  
     ③模块端口变量声明原则：
         输入端口：wire  
         输出端口：看输出变量在模块内部是如何被驱动的：1）assign——>wire     2）always/initial ——>reg
     ④实例化格式：<模块名> <实例名> ( .<端口名> (连接的信号), ... );

第二章：程序设计类型-数据流建模-行为级建模-结构化建模
一、行为级建模各类别
    | 类别         | 语句类型          | 可综合性 | 硬件理解与说明                                                              
    |--------------|-------------------|----------|-------------------------------------------------------------------------------|
    | 过程语句     | initial           | ❌       | 硬件无对应。仅用于仿真初始化，综合工具会忽略。                                
    |              | always            | ✅       | 核心可综合块。代表持续活动的硬件单元。                                       
    | 语句块       | begin-end         | ✅       | 顺序块。用于组合多条语句，综合为等效电路。                                   
    |              | fork-join         | ❌       | 并行块。无硬件对应，仅用于仿真。                                            
    | 赋值语句     | assign            | ✅       | 连续赋值。代表物理连线或组合逻辑电路。                                      
    |              | =、<=             | ✅       | 过程赋值。阻塞(=)用于组合逻辑，非阻塞(<=)用于时序逻辑。                       
    | 条件语句     | if-else           | ✅       | 综合为多路选择器(MUX)或优先级逻辑。条件不全会产生锁存器。                     
    |              | case/casez/casex  | ✅       | 综合为多路选择器或译码器。casez/casex需谨慎使用。                            
    | 循环语句     | for               | ✅       | 可综合，但循环次数需为编译时常量。综合工具会展开循环为多份硬件。              
    |              | while/repeat/forever | ❌    | 硬件无对应。仅用于仿真。                                                     
    | 编译向导     | `define           | ✅       | 宏定义。综合前进行文本替换，不影响硬件结构。                                 
    |              | `include          | ✅       | 文件包含。综合前插入文件内容，等同于代码合并。                                
    |              | `ifdef/`else/`endif | ✅     | 条件编译。根据宏定义决定部分代码是否参与综合。     
1、过程连续赋值语句：
    assign 寄存器类型变量 = 赋值表达质
    deassign 寄存器类型变量 
    ①连续赋值语句只能用于寄存器类型变量
    ②重新赋值语句用于释放assign对寄存器变量的连续赋值，保持被执行前的原有取值
    ③仅限于仿真写法，实际硬件不综合
        reg x, y, en;
        always @(*) begin
            if (en)
                assign x = y;  // x 跟随 y
            else
                deassign x;    // 取消跟随，x 保持最后一次的值
        end

2、强制语句和释放语句
    force 寄存器/连线型变量 = 赋值表达式    force 的优先级高于assign语句
    release 寄存器/连线型变量
    ①以上两种不可综合，用于仿真语句
    ②force 一般用于强制某个语句表达持续多长时间，然后右release释放

3、条件分支语句
    ①if / if - else / if -else if
    if (条件表达式) 语句块 ：条件表达式成立，执行语句块，否则跳过这一步
    if (条件表达式) 语句块1；else 语句块2 ：条件表达式成立，执行语句块1，否执行语句块2
    if (条件表达式1) 语句块1；else if(条件表达式2) 语句块2 …… else ：依条件表达式顺序判断条件是否成立，然后决定是否执行语句块。存在顺序优先级逻辑
    if 嵌套：根据从外到内，按照上诉三种逻辑决策
    ②case 
    case (控制表达式)
        值1：语句块1
        值2：语句块2
        ……
        值n：语句块n
        default:语句块n+1
    endcase
        1、值的位宽必须相等，控制表达式和分支表达式才能进行对位比较。
        2、case 的控制表达式产生的所有可能，如果在值中没有完全被列举就会产生锁存器
        always @(*) begin
            case (sel)
                2'b00: out = a;
                2'b01: out = b;
                2'b10: out = c;
                //当sel=2‘b11 时，out在例举中找不到，就会默认保持上一状态的值，从而激发锁存器的性质
            endcase
        end
4、循环语句
    ①forever 语句/语句块
        1）永久循环，直至遇到$finish 
        2）一般用于周期性波形的产生
        3）如果forever 后 没有加延时，则会0延时立即产生永久循环
    ②repeat(循环次数)
        1）执行固定次数的循环
        2）循环次数可以是长量，变量，信号。执行逻辑是先计算循环次数的值，然后循环次数保持，使循环执行目标次数
    ③while (条件表达式) 语句/语句块
        1）执行逻辑，判断条件表达式是否为1，如果是执行到语句结束，再次判断是否为1，然后循环直至判断条件为假后跳出。
    ④for (循环变量初值；循环结束条件；循环变量递增) 语句块


二、结构化建模
1、模块级建模
    ①模块调用语法格式：模块名 <参数值列表> 实例名(端口名列表);
    ②同一模块多次被调用，利用阵列的方式进行表达：模块名 实例阵列名 [用位宽定义被调用数目] (端口连接表);
    ③模块端口对应方式：
        1）<模块名> <实例名> ( .<端口名> (连接的信号), ... );
        2）严格按照模块定义声明的端口顺序进行连接
    ④参数传递机制
        1）顺序传递，严格按照参数顺序传递：模块名 #(传递值,传递值……) 实例化名 (端口名列表)
        2）按参数名传递：模块名 #(.para1(传递值),para2(传递值)……) 实例化名 (端口名列表)
        
