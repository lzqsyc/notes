第一章基础语法知识：
1、verilog语法学习，使用蔡觉平老师的书籍与网络视频课
    ①语言要素的学习：空白符、注释符、标识符、关键字、数值的理解
    ②数据类型：物理数据类型，连线型和寄存器，存储器类型，抽象数据类型
    ③wire 和 reg 数据类型的使用场景选择分析：
       wire(导线) ：赋值方式(assign+模块端口之间)     reg(触发器、锁存器)：always 、initial  语句块内，
       使用技巧：看左边定类型，assign用wire，always 用reg  
2、寄存器类型与存储器类型的区别：                 
    ①reg 是一种数据对象类型，在 always 或 initial 块中赋值）的变量  硬件对应：触发器、锁存器    用于存储单个数据
    ②memory 由多个 reg 变量组成的一维或多维数组，对应数据结构，硬件对应：RAM ROM SRAM  
    ③声明一个存储器（1024 x 8位的RAM）：reg [7:0] ram [0:1023];
3、理解抽象数据类型：
    ①常见类型：整型(integer)，实数型(real),字符串(string), 时间型(time)   都没有对应的硬件，且不可以综合，用于仿真、
4、阻塞语句（=）、非阻塞的本质区别（<=）
   ① =，顺序执行，立即计算=右边，然后立即赋值给=左边，每条指令结束再执行下一条指令。
    硬件层面：对应组合逻辑，中间没有触发器做隔离，输入变化会立即导致逻辑运算，
    使用场景：组合逻辑设计
   ②<=，并行执行，所有=右边同时计算，然后同时统一赋值更新=左边，在整个语句块中同时进行。对应时序逻辑
    硬件层面：非阻塞语句对应中间存在触发器采样处理，但是新采样的值都需要等待下一个时钟周期。所以在一个语句快内，
                        所有的=左边的计算都属于当前时钟周期的同步采用，而赋值属于下一周的采样更新处理。
    使用场景：时序逻辑设计
5、学习verilog中的运算符以及其优先级：
     ①算术运算符：+  -  *  /  %    运算有无符号取决于操作数的数据类型。混合运算时无符号默认提升有符号，易出错。溢出自动截断高位
     ②关系运算符：>  <  >=  <=   返回单比特值：1 / 0
     ③相等运算符：==  !=  ===  !==    ==和！=（不比较x/z 若存在x/z 则结果为x） ===和！== (比较x/z 主要用于testbench仿真)
     ④逻辑运算符：!   &&   ||     操作位可以多位的，返回值为单比特结果；存在短路求值：a && b，如果 a 为0，则不会计算 b (仿真器的行为)
     ⑤按位运算符：~   &   |   ^    ~^     操作数位宽不同，较短的操作数会在高位补0； yu逻辑运算不同，返回值按位产生同等位数据结果
     ⑥归约运算符：串行处理单一变量的多位宽，从左向右相邻位宽逻辑运算最后纵向压缩成单比特位：0 / 1   
     ⑦移位运算符：<<   >>   <<<    >>>    逻辑移位视为无符号数，空位补0；算术移位视为有符号运算，
         算术移位保持高位符号不变，高位空缺补符号位，低位补0；特别是算术右移：右移近似于除以2的幂
     ⑧条件运算符：?     条件1 ？表达真：表达假    相当于综合一个2路选择器    ；可以嵌套使用
     ⑨连接与复制：{ }     {{  }}     假设a=1'b1,b=2'b10
         连接：{ }    c = {a,b} = 3'b110       连接：属于位宽之间的直接拼接，直接增大位宽。
         复制：{{}}   d = {2{a}} = 2b'10      
         混合：连接与复制   e = {c,{2{a}}}    嵌套使用从最里面往外看，先复制，后连接    e= 5'b11010
6、模块和端口的关系，以及模块实例化：
     ①子模块之间的连接属于物理层面的连线，全局声明wire变量用于模块A的输出连接模块B的输入
     ②模块本身的端口数据类型严格按照数据类型分类，常见常用wire 与reg  
     ③模块端口变量声明原则：
         输入端口：wire  
         输出端口：看输出变量在模块内部是如何被驱动的：1）assign——>wire     2）always/initial ——>reg
     ④实例化格式：<模块名> <实例名> ( .<端口名> (连接的信号), ... );

第二章：程序设计类型-数据流建模-行为级建模-结构化建模
111
