{
gcc编译指令：
	gcc -g -o name1 name2.c   
	-g :生成调试信息
	-o name1:指定生成可知可执行文件名
	name2:c源文件
	./name1		运行c程序
gcc编译查看所有警告：
	CFLAGS="-Wall" make name (name:所需要查看的可执行文件名) 等价于下面的执行语句
	gcc -Wall -o ex1 ex1.c    //以上两句等价  且完全等价于系统内部执行命令，如下
	cc -Wall name.c -o name    
	(使用C编译器编译name.c源文件，生成名为name的可执行文件，并在编译过程中启用所有警告检查" ) 
	
	1、行末尾； 在利用"-Wall"检查时会被忽略 导致无法检测
	2、定义了返回值的函数没有返回值都不报错
第二种编译输入：
	make name (源文件相同名称才可执行) = gcc name.c -o nameout (nameout 输出可的执行文件)
	./name      // 执行编译文件name
	rm
gdb:调试生成的可执行文件name1 gdb常用调试命令
	gdb ./name1  //进行可执行文件调试
	break	(b) 		断点设置：break name2.c:x   x:程序代码所在行
	run  	(r)			启动程序
	next 	(n)			单步执行（不进入函数）
	step	(s)			单步执行（要进入函数）
	print	(p)			打印变量数值：print x       打印变量x的数值 
	quit	(q)			退出gdb	
	watch   (w)			变量监控 ：w x              监控变量x 
	list    (l)			查看源代码
	continue (c)	当前断点继续运行至下一个断点/程序结束
	backtace (bt)	显示函数调用堆栈

}

{
linux 指令学习
软件下载安装：
官网下载最新的x86-64 /amd64 软件包.deb
进入包的目录：利用apt包管理器安装自动处理环境依赖：
	cd ~/Downloads
	sudo apt install ./<软件包文件名>.deb
	./	表示当前路径

目录：~   等价于家目录：/home/luo
cd—切换目录
	cd ~		回到当前用户主目录
	cd /		进入系统根目录  cd/C_study	进入根目录下的C_study 文件夹
	cd -		回到上次目录
	cd gc..		返回上一级目录
	pwd			查看当前文件目录
	
ls :根目录相关  ls - 参数 目录名称
文件分类：u (r d) 所有者		g(r) 所属组		o(r) 其他人		 r 读	w 写		x 执行 
	ls 			显示当前目录文件
	ls -a		显示所有目录文件，包括隐藏文件
	ls -l		显示目录文件参数
	ls -lh		显示目录文件具体参数大小
	ls -d		显示当前目录属性
	ls -i		查看所属目录文件 节点
	-	文件 	d	目录		l	链接
	
mkdir 	:创建目录文件夹
	mkdir <目录名>
	mkdir -p dir1/dir2/dir3		创建多级目录
touch	:创建文件
	touch <文件名>
rm		:删除目录、文件
	rm <文件名>
	rm -f		强制删除文件
	rm -r 		强制删除目录以及内容
cp		:复制
	cp <文件名> <重命名>					复制到当前目录下
	cp <文件名> ~/dir1/dir2/				复制文件到某目录下
	cp a.txt b.txt c.txt ~/dir1/dir2/	复制多个文件到某目录下
	cp -r dir0 ~/dir1/dir2/				复制整个目录到某目录下
	cp -rp dir1 ~/dir1/dir2/			保留目录文件属性复制
mv		:移动
	mv file.txt ~/dir1/dir2/ 			移动文件到某目录下
	mv old.txt new.txt      			当下目录下重命名文件
	mv a.txt ~/dir1/dir2/b.txt			移动文件到某目录下并重命名
	mv a.txt b.txt c.txt ~/dir1/dir2/	移动多个文件到某目录下
	mv ~/dir0/dir1/* ~/dir0/dir3/    	将dir1中的所有文件移动到dir3目录中

查看文件内容的命令：
cat		:显示文件内容，						cat <文件名>
less	:分页查看文件内容，支持下翻页：↑/↓	less <文件名>
more	:分页查看文件内容					more <文件名>
head	:查看前几行，默认前10行				head <文件名>
tail  	:查看后几行，默认后10行				tail <文件名>
q 		:退出

创建和输出文本内容：
echo 					：输出内容（写入文件）			echo "hello world"
echo "内容" > <文件名>	：将文件内容覆盖为 写入内容 		echo "First line" > log.txt
echo "内容" > <文件名>	：追加内容写入文件					echo "Another line" >> log.txt

文件合并：
	cat <文件1> <文件2> > <文件3>





	


}
			
{
make 编译内核或源码文件:不同参数对应的作用：make -参数 目标文件
	它会通过扫描 Makefile 文件找到目标及其依赖关系，并在建立依赖关系后依次编译所对应的源码程序
	执行make clean 会根据makefile 顺序执行，然后清除  不可make clean 文件名单独执行清除处理
变量符号
	$		符号表示取变量的值，当变量名多于一个字符时，使用"( )"
	$		符的其他用法:
	$^ 		表示所有的依赖文件
	$@ 		表示生成的目标文件
	$< 		代表第一个依赖文件
	
变量赋值：
	"="		普通赋值
	":="	直接赋值
	"?="	如果该变量没有被赋值，赋值予等号后面的值
	"+="	将符号后面的值添加到前面的变量上
	
预定义变量：
	cc=gcc	
	
函数：
	SRC		SRC=$(wildcard 目录1/*.c) 						自动获取目录1下的所有.c文件
	OBJ		OBJ=$(patsubst 目录1/%.c,文件名2/%.o,$(Scr))		将目录1下获取的.c文件名替换为.o（放到目录2）
	
伪目标：.PHONY
	伪目标只是一个标签，clean是个伪目标没有依赖文件，只有用make来调用时才会执行
代码清理clean：清理make命令所产生的所有文件
clean:
	rm-f 文件名
	

	-b		忽略兼容性
	-B		始终编译指定的目标文件
	-C		更改为指定的目录
	-r		用内置的隐含规则
	-d		显示调试信息
	-e		使用环境变量覆盖Makefile文件
	-f		读取指定文件作为Makefile文件
	-i		忽视指令被用于重新生成文件时产生的错误
	-I		搜索指定目录中包含的Makefile文件
	-j		完成指定工作编号的作业
	-k		当某个目标不能make时，继续执行任务
	-l		低于指定负载时，才会启动多个任务
	-L		使用最后的修改时间
	-n		不实际运行任何命令
	-o		不编译指定的文件
	-p		显示内部数据库
	-q		使用安静模式
	-r      目录
	-R		禁用内置变量
	-s		静默执行模式
	-S
	-t		创建指定目标
	-v		显示版本信息
	-w		显示当前目录
	-W		设置目标文件
}
	
	
Valgrind 软件的作用：
	memcheck:检测内存泄露，能够追踪每一块分配的内存，并在程序结束时检测分配的内存是否正确释放
			:检测为初始化的变量，比如，如果访问了一个局部变量而没有给它赋值
			:检测数组越界访问，例如读取或写入超出数组边界的内存
			:内存访问错误，如果程序试图访问已释放的内存或非法内存地址，会检测到并报告这种错误。
			:堆栈溢出检测，在递归调用或数组分配时，可能会出现堆栈溢出。通过监控堆栈的使用情况来检测此类问题
	callgrind:性能与缓存优化分析
			:性能优化分析，callgrind 通过采样程序的运行状态，生成关于程序性能的详细报告，
			   能够帮助你分析程序的执行路径、函数调用频率以及热点代码（耗时最多的部分）
			:缓存优化分析,用于模拟和分析程序对 CPU 缓存的使用情况
	Helgrind:门用于多线程程序的调试，能够检测数据竞争、死锁等多线程相关的错误。
	
	
	
	
	
	
	
	
	
	
	
	
