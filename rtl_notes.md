# RTL 设计与 Verilog 学习笔记

## 目录
- [第一章：基础语法知识](#第一章基础语法知识)
- [第二章：程序设计类型与建模](#第二章程序设计类型与建模)

## 第一章：基础语法知识

### 1. Verilog 语法学习
参考资料：蔡觉平老师的书籍与网络视频课。

#### 1.1 语言要素
- **空白符**：空格、制表符、换行符，用于分隔标识符，编译时被忽略。
- **注释符**：
  - 单行注释：`//`
  - 多行注释：`/* ... */`
- **标识符**：变量名、模块名等，由字母、数字、下划线 `_` 和美元符号 `$` 组成，区分大小写，不能以数字开头。
- **关键字**：Verilog 预定义的保留字，如 `module`, `reg`, `wire`, `always` 等。
- **数值**：
  - 格式：`<位宽>'<进制><数值>`
  - 示例：`4'b1010` (4位二进制), `8'hFF` (8位十六进制), `100` (默认32位十进制)。

#### 1.2 数据类型
- **物理数据类型**：
  - **连线型 (Net Type)**：如 `wire`, `tri`。表示物理连线，不能存储值，必须由驱动源驱动。
  - **寄存器型 (Register Type)**：如 `reg`, `integer`。表示数据存储单元，保持最后一次赋值。
- **存储器类型 (Memory)**：由多个寄存器组成的数组。
- **抽象数据类型**：`integer`, `real`, `string`, `time`。无对应硬件，不可综合，主要用于仿真。

#### 1.3 wire 和 reg 的使用场景
| 类型 | 赋值方式 | 场景 | 硬件对应 |
| :--- | :--- | :--- | :--- |
| **wire** | `assign` 语句<br>模块实例化端口连接 | 组合逻辑连线 | 导线 |
| **reg** | `always` 块内部<br>`initial` 块内部 | 时序逻辑<br>组合逻辑 (always @*) | 触发器 (Flip-Flop)<br>锁存器 (Latch)<br>导线 (组合逻辑时) |

**使用技巧**：看赋值号左边。
- 左边是 `assign` -> 用 `wire`
- 左边在 `always` 块内 -> 用 `reg`

### 2. 寄存器与存储器

#### 2.1 寄存器 (reg)
- **定义**：一种数据对象类型，在 `always` 或 `initial` 块中被赋值。
- **硬件对应**：触发器 (DFF)、锁存器 (Latch)。
- **用途**：存储单个数据。

#### 2.2 存储器 (Memory)
- **定义**：由多个 `reg` 变量组成的一维或多维数组。
- **硬件对应**：RAM, ROM, SRAM。
- **声明示例**：
  ```verilog
  // 声明一个 1024 x 8位的 RAM
  // [7:0] 是数据位宽 (8位)
  // [0:1023] 是地址深度 (1024个单元)
  reg [7:0] ram [0:1023];
  ```

### 3. 抽象数据类型
- **常见类型**：
  - `integer` (整型)
  - `real` (实数型)
  - `string` (字符串)
  - `time` (时间型)
- **特点**：没有对应的硬件电路，**不可综合**，仅用于仿真测试 (Testbench)。

### 4. 阻塞与非阻塞赋值

#### 4.1 阻塞赋值 (`=`)
- **执行方式**：顺序执行。立即计算 `=` 右边，立即赋值给左边。下一条语句必须等待当前语句完成。
- **硬件对应**：组合逻辑。中间无触发器隔离，输入变化立即引起输出变化。
- **使用场景**：**组合逻辑设计** (`always @(*)`)。

#### 4.2 非阻塞赋值 (`<=`)
- **执行方式**：并行执行。块内所有语句的右边同时计算，块结束后统一赋值给左边。
- **硬件对应**：时序逻辑。中间存在触发器 (Flip-Flop)。
  - **计算**：基于当前时钟周期的值。
  - **更新**：在时钟边沿到来后（下一周期）更新。
- **使用场景**：**时序逻辑设计** (`always @(posedge clk)`)。

#### 4.3 混合使用后果
- 时序逻辑用阻塞赋值 (`=`)：可能导致竞争冒险，仿真结果依赖编译器顺序，产生不可预知的时序错误。
- 组合逻辑用非阻塞赋值 (`<=`)：可能产生意外的锁存器或延时一拍的效果。

### 5. 运算符

#### 5.1 算术运算符
- `+`, `-`, `*`, `/`, `%`
- **注意**：
  - 运算结果的符号取决于操作数类型。
  - 混合运算时，无符号数默认提升为有符号数，易出错。
  - 溢出时自动截断高位。

#### 5.2 关系运算符
- `>`, `<`, `>=`, `<=`
- **结果**：返回单比特值 `1` (真) 或 `0` (假)。

#### 5.3 相等运算符
- `==`, `!=`：逻辑相等/不等。若操作数含 `x` 或 `z`，结果为 `x`。
- `===`, `!==`：全等/不全等。包括 `x` 和 `z` 的精确比较。**仅用于仿真**。

#### 5.4 逻辑运算符
- `!`, `&&`, `||`
- **特点**：操作数可以是多位，但结果为单比特。
- **短路求值**：如 `a && b`，若 `a` 为 0，则不计算 `b` (仿真器行为)。

#### 5.5 按位运算符
- `~`, `&`, `|`, `^`, `~^` (同或)
- **特点**：按位进行逻辑运算，生成同等位宽的结果。
- **位宽不同**：短操作数高位补 0。

#### 5.6 归约运算符 (缩减运算符)
- 单目运算，如 `&a` (对 a 的所有位进行与运算)。
- **特点**：将多位宽变量从左向右进行逻辑运算，最终压缩为 **1 bit** 结果。

#### 5.7 移位运算符
- **逻辑移位**：`<<`, `>>`。视为无符号数，空位补 0。
- **算术移位**：`<<<`, `>>>`。视为有符号数。
  - 算术左移 `<<<`：低位补 0。
  - 算术右移 `>>>`：**高位补符号位**。近似于除以 $2^n$。

#### 5.8 条件运算符
- `condition ? expr1 : expr2`
- **硬件对应**：2路选择器 (MUX)。
- 可嵌套使用。

#### 5.9 连接与复制
- **连接 `{}`**：`c = {a, b}` (位宽拼接)。
- **复制 `{{}}`**：`d = {2{a}}` (重复 a 两次)。
- **混合**：`e = {c, {2{a}}}` (先复制，后拼接)。

### 6. 模块与实例化

#### 6.1 模块端口
- **输入端口 (input)**：必须是 `wire` 类型。
- **输出端口 (output)**：
  - 被 `assign` 驱动 -> `wire`
  - 被 `always/initial` 驱动 -> `reg`

#### 6.2 实例化格式
```verilog
// 推荐使用命名连接，而非位置连接
Module_Name Instance_Name (
    .Port_Name1 (Signal_Name1),
    .Port_Name2 (Signal_Name2)
);
```

---

## 第二章：程序设计类型与建模

### 1. 行为级建模类别

| 类别 | 语句类型 | 可综合性 | 硬件理解与说明 |
| :--- | :--- | :--- | :--- |
| **过程语句** | `initial` | ❌ | 仅用于仿真初始化，综合工具忽略。 |
| | `always` | ✅ | 核心可综合块，代表持续活动的硬件单元。 |
| **语句块** | `begin-end` | ✅ | 顺序块。组合多条语句。 |
| | `fork-join` | ❌ | 并行块。仅用于仿真。 |
| **赋值语句** | `assign` | ✅ | 连续赋值。代表物理连线或组合逻辑。 |
| | `=`, `<=` | ✅ | 过程赋值。阻塞(=)组合逻辑，非阻塞(<=)时序逻辑。 |
| **条件语句** | `if-else` | ✅ | MUX 或优先级逻辑。条件不全可能产生锁存器。 |
| | `case` | ✅ | MUX 或译码器。`casez`/`casex` 需谨慎。 |
| **循环语句** | `for` | ✅ | 循环次数需为常量。综合为多份硬件展开。 |
| | `while`... | ❌ | 仅用于仿真。 |
| **编译向导** | `` `define `` | ✅ | 宏定义。文本替换。 |
| | `` `include `` | ✅ | 文件包含。 |
| | `` `ifdef `` | ✅ | 条件编译。 |

### 2. 过程连续赋值 (仿真用)
- `assign` / `deassign`：用于寄存器变量。
- `force` / `release`：强制赋值，优先级最高。仅用于仿真调试。

### 3. 条件分支语句
- **if-else**：具有优先级。
- **case**：
  - 必须位宽相等才能匹配。
  - **锁存器警告**：如果 `case` 没有列举所有可能且无 `default`，会产生锁存器 (Latch)。

### 4. 循环语句
- `forever`：永久循环 (需配合延时，否则死循环)。
- `repeat(n)`：执行固定次数。
- `while(cond)`：条件循环。
- `for`：`for (init; cond; step)`。

### 5. 结构化建模
- **模块调用**：`Module_Name #(.Para(Val)) Inst_Name (.Port(Sig));`
- **阵列实例化**：`Module_Name Inst_Array [N-1:0] (...);`
- **参数传递**：
  - `#(val1, val2)` (位置传递)
  - `#(.P1(v1), .P2(v2))` (命名传递 - 推荐)
